{
  "Comment": "The Audit Event State Machine, responsible for generating the overall event structure",
  "StartAt": "Get Audit name components",
  "States": {
    "Get Audit name components": {
      "Type": "Pass",
      "Comment": "The details JSON object is stringified using States.JsonToString and then split it on ':\"' creating an array with key and value as items if a key called evidence is found DetailsContainsEvidence returns boolean value true",
      "Parameters": {
        "prefix.$": "$$.Execution.Input.detail.auditPrefix",
        "type.$": "$$.Execution.Input.detail-type",
        "DetailsContainsEvidence.$": "States.ArrayContains(States.StringSplit(States.JsonToString($$.Execution.Input.detail), ':\"'), 'evidence')"
      },
      "Next": "Parallel"
    },
    "Parallel": {
      "Type": "Parallel",
      "Next": "Is Restricted Info Present?",
      "Branches": [
        {
          "StartAt": "Get AuditContext Restricted Info",
          "States": {
            "Get AuditContext Restricted Info": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${CredentialSubjectFunctionArn}",
                "Payload.$": "$$.Execution.Input.detail"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2
                }
              ],
              "ResultSelector": {
                "value.$": "$.Payload",
                "containsUserInfo.$": "States.JsonToString($.Payload)"
              },
              "ResultPath": "$.restricted",
              "End": true
            }
          }
        },
        {
          "StartAt": "EpochTime in Seconds",
          "States": {
            "EpochTime in Seconds": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload": {
                  "dateTime.$": "$$.State.EnteredTime",
                  "unit": "seconds"
                },
                "FunctionName": "${EpochTimeArn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2
                }
              ],
              "ResultSelector": {
                "value.$": "$.Payload"
              },
              "ResultPath": "$.epochSeconds",
              "End": true
            }
          }
        },
        {
          "StartAt": "EpochTime In Milliseconds",
          "States": {
            "EpochTime In Milliseconds": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "Payload": {
                  "dateTime.$": "$$.State.EnteredTime",
                  "unit": "milliseconds"
                },
                "FunctionName": "${EpochTimeArn}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2
                }
              ],
              "ResultSelector": {
                "value.$": "$.Payload"
              },
              "ResultPath": "$.epochMilliseconds",
              "End": true
            }
          }
        }
      ]
    },
    "Is Restricted Info Present?": {
      "Type": "Choice",
      "Comment": "This check uses the empty object returned from the CredentialSubjectFunction to determine there is no Restricted user info present",
      "Choices": [
        {
          "Variable": "$[0].restricted.containsUserInfo",
          "StringEquals": "{}",
          "Next": "AuditEvent Without Restricted Info"
        }
      ],
      "Default": "Add Restricted Info to AuditEvent"
    },
    "AuditEvent Without Restricted Info": {
      "Type": "Pass",
      "Comment": "The user context info is returned only is there is no Restricted user information",
      "Parameters": {
        "event_name.$": "States.Format('{}_{}', $[0].prefix, $[0].type)",
        "timestamp.$": "$[1].epochSeconds.value",
        "event_timestamp_ms.$": "$[2].epochMilliseconds.value",
        "component_id.$": "$$.Execution.Input.detail.issuer",
        "user.$": "$$.Execution.Input.detail.user"
      },
      "ResultPath": "$[0].auditEvent",
      "OutputPath": "$",
      "Next": "Is evidence Present?"
    },
    "Add Restricted Info to AuditEvent": {
      "Type": "Pass",
      "Comment": "The user context info is returned in added with the Restricted user information",
      "Parameters": {
        "event_name.$": "States.Format('{}_{}', $[0].prefix, $[0].type)",
        "timestamp.$": "$[1].epochSeconds.value",
        "event_timestamp_ms.$": "$[2].epochMilliseconds.value",
        "component_id.$": "$$.Execution.Input.detail.issuer",
        "user.$": "$$.Execution.Input.detail.user",
        "restricted.$": "$[0].restricted.value"
      },
      "ResultPath": "$[0].auditEvent",
      "OutputPath": "$",
      "Next": "Is evidence Present?"
    },
    "Is evidence Present?": {
      "Type": "Choice",
      "Comment": "This check uses the DetailsContainsEvidence boolean to know when to add evidence details to the audit structure",
      "Choices": [
        {
          "Variable": "$[0].DetailsContainsEvidence",
          "BooleanEquals": true,
          "Next": "Audit Event With Evidence & Restricted Info"
        }
      ],
      "Default": "Add User Context"
    },
    "Add User Context": {
      "Type": "Pass",
      "Parameters": {
        "auditEvent.$": "$.[0].auditEvent"
      },
      "ResultPath": "$[0]",
      "OutputPath": "$",
      "Next": "publish event to TxMa Queue"
    },
    "Audit Event With Evidence & Restricted Info": {
      "Type": "Pass",
      "Comment": "Merges the evidence detail contained in the details input by interpolating is into a stringified version of {evidence: {}}, {} is replaced with string form of the incoming evidence detail, which is then converted to Json and merge with the auditEvent state",
      "Parameters": {
        "auditEvent.$": "States.JsonMerge($.[0].auditEvent, States.StringToJson(States.Format('\\{\"extensions\":\\{\"evidence\": {}\\}\\}', States.JsonToString($$.Execution.Input.detail.evidence))), false)"
      },
      "ResultPath": "$[0]",
      "OutputPath": "$",
      "Next": "publish event to TxMa Queue"
    },
    "publish event to TxMa Queue": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sqs:sendMessage",
      "Parameters": {
        "QueueUrl": "${SqsAuditEventQueueUrl}",
        "MessageBody.$": "$"
      },
      "End": true
    }
  }
}
